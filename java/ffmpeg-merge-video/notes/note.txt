
镜头切割需要优化。

35个格子。每个2s

=========================== changed file =====================

VEGapUtils


重复镜头。。后面需要处理
声音识别
黑镜头(比较暗的镜头)--  可能有比较好的暗的镜头

=====================================================================
问题整理 5.30：
      1, 一些好的镜头(人脸切不出来)和不好的镜头. (C2018 - 人脸不稳定)
      2, 格子比镜头少很多（小于1/2 / 1/3） 时， 优先保留单个故事完整性，还是保留重要的故事.
         ps: 现在还无法识别故事的重要性，所以保留重要的故事，就无法保证

============================= 暗识别 ok =================================

https://blog.csdn.net/qq249356520/article/details/78864244
java Color, ImageIO, BufferImage



================= 微积分 ========================
加减法代替积分的运算
求积分 -》 微分
     如果函数找得到。 某一点的微分刚好是f(x)的值。
     切线斜率(微分值)  f(x)dx/ dx. 恰好等于原函数f(x) 积分值.
     f(x)dx -- dx
     ps: dx = delta x

微分是非常确定的线性函数(积分的近似)。
      dy = f'(x) dx
      f'(x) = (f(x+h) - f(x)) / h
99.99%的函数积分找不到

==================== 极限 导数 ==============================
求导 = 微分 = 求切线的斜率

常数函数 f(x) = c 导数(微分)为0
  没有倾斜，所以导数为0

f'(x) = lim(h->0) upper(f(x+h)- f(x))/h
极限性质：
        1, 常数：  f(x) = ck(x);

        lim(h->0) upper(f(x+h)-f(x)) /  h =  lim(h->0) upper(ck(x+h)-ck(x)) /  h
        = c*  lim(h->0) upper k(x+h)-k(x)/h = c*k'(x)

        2, 加法. f(x) = m(x) + n(x)
          导数f'(x) = m'(x) + n'(x)
          和的极限等于极限的和

        3, 乘法. f(x)=m(x)*m(x)
        导数(微分)
        f'(x) = [m(x)*g(x)]' = m'n + mn' //下面是证明
              = lim(h->0) upper( m(x+h)n(x+h) - m(x)n(x) )/h
              // 分成2项，分别加 和 减  m(x+h) * n(x)/h
              = lim(h->0) upper( m(x+h)[n(x+h) - nx] ) /h
                 + lim(h->0) upper ( n(x)[m(x+h) - m(x)] )/ h
              = m(x+h)n' +  n(x)m'
                 //h->0
              = m(x)n' +  n(x)m'
        ps:
         f'(x) = [m(x)*g(x)]' != m'* n'


        4, 除法
        h(x) = f(x) / g(x)
        h'(x) = ( g(x)f'(x) - g'(x)f(x) ) / [g(x)]^2
        //证明： 可以用乘法的性质.
        // f(x) = h(x) * g(x)    h(x) = f(x)* 1 /g(x)=f(x) * g-1(x)
        // 证明 impl
        f'(x) = h'(x)g(x) + g'(x)h(x)
        h'(x) = (f'(x) - g'(x)h(x) )/g(x)
              = (f'(x) - g'(x) (f(x) / g(x))) / g(x)
              = (g(x)*f'(x)- g'(x)f(x)) / [g(x)]^2

   利用除法性质。 (指数的微分)
    if 整数n < 0 ,  则 (x^n)' = ?   //x的n次方的导数
   // 计算 impl
    let m = -n.  so m > 0.
    (x^n)' = (x^-m)' = (1/ x^m)'
                     =[ x^m (1)' - 1* (x^m)'] / x^(2m)
                     =-(x^m)'/x^(2m)
                     =-m * (x^(m-1)) / x^(2m) = -m * x ^ (-m-1) = n* x^(n-1)

