

本项目主要学习:
         Coroutine = 协程（轻量级线程）: https://studygolang.com/articles/11134
         相关文章：
               http://blog.csdn.net/qq_32115439/article/details/74018755
  next:
           通道 vs 阻塞队列


   ================ 概念 ================
   直接先说区别，协程是编译器级的，而线程是操作系统级的。

   协程通常是由编译器来实现的机制。线程看起来也在语言层次，但是内在原理却是操作系统先有这个东西，然后通过一定的API暴露给用户使用，两者在这里有不同。

   协程就是用户空间下的线程。用协程来做的东西，用线程或进程通常也是一样可以做的，但往往多了许多加锁和通信的操作。

   线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程， 因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

   协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行,
   线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor),

   执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。

   线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

   ==================================

=================== 协程的好处 ======================================
    与多线程、多进程等并发模型不同，协程依靠user-space调度，而线程、进程则是依靠kernel来进行调度。线程、进程间切换都需要从用户态进入内核态，
    而协程的切换完全是在用户态完成，且不像线程进行抢占式调度，协程是非抢占式的调度。

    通常多个运行在同一调度器中的协程运行在一个线程内，这也消除掉了多线程同步等带来的编程复杂性。同一时刻同一调度器中的协程只有一个会处于运行状态。

    我们使用协程，程序只在用户空间内切换上下文，不再陷入内核来做线程切换，这样可以避免大量的用户空间和内核空间之间的数据拷贝，
    降低了CPU的消耗，从而大大减缓高并发场景时CPU瓶颈的窘境。

    另外，使用协程，我们不再需要像异步编程时写那么一堆callback函数，代码结构不再支离破碎，整个代码逻辑上看上去和同步代码没什么区别，简单，易理解，优雅。

    我们使用协程，我们可以很简单地实现一个可以随时中断随时恢复的函数。

    一些 API 启动长时间运行的操作(例如网络 IO、文件 IO、CPU 或 GPU 密集型任务等)，并要求调用者阻塞直到它们完成。
    协程提供了一种避免阻塞线程并用更廉价、更可控的操作替代线程阻塞的方法：协程挂起。

    协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。
    该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程(甚至不同机器)上调度执行，而代码则保持如同顺序执行一样简单。


================================= 阻塞 vs 挂起 ==========================
     协程可以被挂起而无需阻塞线程。而线程阻塞的代价通常是昂贵的，尤其在高负载时，阻塞其中一个会导致一些重要的任务被延迟。

     另外，协程挂起几乎是无代价的。不需要上下文切换或者 OS 的任何其他干预。

     最重要的是，挂起可以在很大程度上由用户来控制，我们可以决定挂起时做些，并根据需求优化、记日志、拦截处理等。

=========================================== 协程---基本原理 =============================================================

协程完全通过编译技术实现(不需要来自 VM 或 OS 端的支持)，挂起机制是通过状态机来实现，其中的状态对应于挂起调用。

在挂起时，对应的协程状态与局部变量等一起被存储在编译器生成的类的字段中。在恢复该协程时，恢复局部变量并且状态机从挂起点接着后面的状态往后执行。

挂起的协程，是作为Continuation对象来存储和传递，Continuation中持有协程挂起状态与局部变量。

================================================================================================================================
//3种调度方式
         launch(CommonPool) {...}
         async(CommonPool) {...}
         run(NonCancellable) {...}



  tcp/ip协议族
 tcp/udp 传输层
 ip 网络层
 http 应用层
 [物理层]， 数据链路层，网络层，传输层，[会话层，表示层]， 应用层
http://blog.csdn.net/Pk_zsq/article/details/6087367